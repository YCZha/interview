# 数据库相关知识总结 

## 数据库引擎InnoDB和MyISAM的区别和优缺点
1. 是否支持行级锁
    - MyISAM 只有表级锁(table-level locking)，而 InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。
2. 是否支持事务
    - MyISAM 不提供事务支持。
    - InnoDB 提供事务支持，具有提交(commit)和回滚(rollback)事务的能力。
3. 是否支持外键
    - MyISAM 不支持，而 InnoDB 支持
    - （一般我们也是不建议在数据库层面使用外键的，应用层面可以解决。不过，这样会对数据的一致性造成威胁。具体要不要使用外键还是要根据你的项目来决定。）
4. 是否支持数据库异常崩溃后的安全恢复
    - MyISAM 不支持，而 InnoDB 支持。
    - 使用 InnoDB 的数据库在异常崩溃后，数据库重新启动的时候会保证数据库恢复到崩溃前的状态。这个恢复的过程依赖于 **redo log** 。
    >  MySQL InnoDB 引擎使用 **redo log(重做日志) 保证事务的持久性**，使用 **undo log(回滚日志) 来保证事务的原子性**。
    >  MySQL InnoDB 引擎通过 **锁机制、MVCC 等手段来保证事务的隔离性**（ 默认支持的隔离级别是 REPEATABLE-READ ）。
    >  保证了事务的**持久性、原子性、隔离性之后，一致性**才能得到保障。
5. 是否支持MVCC
    - MyISAM 不支持，而 InnoDB 支持。

## MVCC
全称Multi-Version Concurrency Control，即多版本并发控制.同一行数据平时发生读写请求时，会上锁阻塞住。但mvcc用更好的方式去处理读—写请求，做到在发生读—写请求冲突时不用加锁。
### 当前读
它读取的数据库记录，都是当前最新的版本，会对当前读取的数据进行加锁，防止其他事务修改数据。是*悲观锁*的一种操作。共享锁、快照锁、串行化隔离级别都是当前读
### 快照读
快照读的实现是基于多版本并发控制，即MVCC，既然是多版本，那么快照读读到的数据不一定是当前最新的数据，有可能是**之前历史版本**的数据。
### MVCC的实现原理
主要是版本链，undo日志 ，Read View来实现的
- 版本链
> 数据库中的每行数据，除了我们肉眼看见的数据，还有几个隐藏字段，得开天眼才能看到。分别是trx_id(记录创建这条记录/最后一次修改该记录的事务ID。)、db_roll_pointer(指向这条记录的上一个版本)。
> 每次对数据库记录进行改动，都会记录一条undo日志，每条undo日志也都有一个roll_pointer属性（INSERT操作对应的undo日志没有该属性，因为该记录并没有更早的版本），可以将这些undo日志都连起来，串成一个链表。
> **对该记录每次更新后，都会将旧值放到一条undo日志中，就算是该记录的一个旧版本，随着更新次数的增多，所有的版本都会被roll_pointer属性连接成一个链表，我们把这个链表称之为版本链，版本链的头节点就是当前记录最新的值。另外，每个版本中还包含生成该版本时对应的事务id(trx_id)，这个信息很重要，在根据ReadView判断版本可见性的时候会用到。**

- undo日志
> Undo log 主要用于记录数据被修改之前的日志，在表信息修改之前先会把数据拷贝到undo log里。当事务进行回滚时可以通过undo log 里的日志进行数据还原。
> undo log主要分两种：insert undo log（代表事务在insert新记录时产生的undo log , 只在事务回滚时需要，并且在事务提交后可以被立即丢弃）、update undo log（事务在进行update或delete时产生的undo log ; 不仅在事务回滚时需要，在快照读时也需要；）

- read View（读视图）
Read View主要是用来做可见性判断的, 即当我们某个事务执行快照读的时候，对该记录创建一个Read View读视图，把它比作条件用来判断当前事务能够看到哪个版本的数据，既可能是当前最新的数据，也有可能是该行记录的undo log里面的某个版本的数据。

## 数据库事务以及其四大特性
事务是逻辑上的一组操作，要么都执行，要么都不执行。四大特性：ACID
1. 原子性（Atomicity） ： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用
2. 一致性（Consistency）： 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；
3. 隔离性（Isolation）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；
4. 持久性（Durability）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。

## 事务并发所引发的问题
1. **脏读（Dirty read）**: 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的
2. **丢失修改（Lost to modify）**: 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事务 1 修改 A=A-1，事务 2 也修改 A=A-1，最终结果 A=19，事务 1 的修改被丢失。
3. **不可重复读（Unrepeatable read）**: 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的**修改**导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。
4. **幻读（Phantom read）**: 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现**多了一些原本不存在的记录**，就好像发生了幻觉一样，所以称为幻读。**Mysql 在RR隔离级别下会加*间隙锁*，解决了幻读的问题**

## SQL定义了事务的隔离级别
1. **READ-UNCOMMITTED(读取未提交)**： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。
2. **READ-COMMITTED(读取已提交)**： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。
3. **REPEATABLE-READ(可重复读)**： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。
4. **SERIALIZABLE(可串行化)**： 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。
> SERIALIZABLE 隔离级别，是通过锁来实现的。除了 SERIALIZABLE 隔离级别，其他的隔离级别都是基于 MVCC 实现。

## 索引
索引是一种用于快速查询和检索数据的数据结构。常见的索引结构有: B 树， B+树和 Hash。使用能快速查询到记录，但是使用索引也会相应的带来一些开销，比如新建索引和维护索引的开销，以及物理空间的开销，同时，如果在记录量不多的情况下，使用索引不一定比直接查询快。

### Hash索引
- 优点：速度快
- 缺点：hash冲突、**Hash 索引不支持顺序和范围查询**(Hash 索引不支持顺序和范围查询是它最大的缺点： 假如我们要对表中的数据进行排序或者进行范围查询，那 Hash 索引可就不行了。

### B树和B+树
目前大部分数据库系统及文件系统都采用 B-Tree 或其变种 B+Tree 作为索引结构。
- B 树的所有节点既存放键(key) 也存放 数据(data)，而 B+树只有叶子节点存放 key 和 data，其他内节点只存放 key。
- B 树的叶子节点都是独立的;B+树的叶子节点有一条引用链指向与它相邻的叶子节点。
- B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。

### 聚集索引和非聚集索引
> 聚集索引
- 索引结构和数据存放在一起的索引，主键索引属于聚集索引
    - 在 MySQL 中，InnoDB 引擎的表的 .ibd文件就包含了该表的索引和数据，对于 InnoDB 引擎表来说，该表的索引(B+树)的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据。
    - 优点：**聚集索引的查询速度非常的快**，因为整个 B+树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。
    - 缺点：1. **依赖于有序的数据**：因为 B+树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或 UUID 这种又长又难比较的数据，插入或查找的速度肯定比较慢。2. **更新代价大** ： 如果对索引列的数据被修改时，那么对应的索引也将会被修改，而且聚集索引的叶子节点还存放着数据，修改代价肯定是较大的，所以对于主键索引来说，主键一般都是不可被修改的。
> 非聚集索引
- 非聚集索引即索引结构和数据分开存放的索引。
    - 优点：更新代价比聚集索引要小 。非聚集索引的更新代价就没有聚集索引那么大了，非聚集索引的叶子节点是不存放数据的
    - 缺点：1. 跟聚集索引一样，非聚集索引也依赖于有序的数据、2. 可能会二次查询(回表) :这应该是非聚集索引最大的缺点了。 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。
> 自增主键的巨大优势是什么？
- 这样进行查询时速度非常快。  因为 B+树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或 UUID 这种又长又难比较的数据，插入或查找的速度肯定比较慢。

### 主键索引和辅助索引（二级索引）
- 主键索引：可以理解成通过主键索引去查询对应的数据记录
- 辅助索引（二级索引）：因为二级索引的叶子节点存储的数据是主键和列值。所以是通过辅助索引去查询对应记录的主键的位置。辅助索引有：唯一索引，普通索引，前缀索引
> 因为辅助索引返回的是主键和列值，所以有时候需要进行回表，但是如果使用了**覆盖索引**就不需要回表，覆盖索引就是指如果查询的索引正好建立了索引，就直接使用这个索引，直接返回，不需要再回表。

### 联合索引
> 最左前缀匹配原则
MySQL 会根据联合索引中的字段顺序，从左到右依次到查询条件中去匹配，如果查询条件中存在与联合索引中最左侧字段相匹配的字段，则就会使用该字段过滤一批数据，直至联合索引中全部字段匹配完成，或者在执行过程中遇到范围查询，如 >**、<、between** 和 以%开头的like查询 等条件，才会停止匹配。