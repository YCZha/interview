# 四种类型显式转换

## static_cast
- 是在编译时进行检查的，没有**运行时检查来保证转换的安全性**
- 可以用于基本类型之间的类型转换，但是转换的安全性需要开发者自己来确定，例如int转char，就是直接截断。
> 不能用于基本类型指针间的转换，void*类型指针和其他类型指针的转换是允许的
- 将空指针转化为目标类型的空指针
- 用于类层次结构中的父类和子类之间的指针和引用的转换
>（如果是上行转换，即子类转化为父类，实际上是一种隐式转换，所以是能成功的。因为子类对象中实际上继承了父类，因此子类对象的地址空间中包含了父类的地址空间，且就在开头，所以此时父类指针访问子类对象是完全正确的。但是子类指针访问父类对象，static_cast不会报错，但此时如果子类指针访问其父类中不存在的成员函数，就会导致地址越界，从而报错）

## const_cast
- 只能改变运算对象的底层的const（去掉const性质）。并且**目标类型是指针或引用**

## reinterpret_cast
- 对内存中的某个数据按照位进行重新解释，比如可以把一个int数据重新解释成指针，字符型数据解释位其他类型的数组，自由度更高，但不推荐使用。

## dynamic_cast
- 运行时进行动态转换，**一般用在静态多态**上
- 进行上行转换时，一般会检查两者是否具有继承关系，如果有则成功
- 进行下行转换时，一个基类指针会指向一个派生类对象，此时会检查这个基类指针指向的实际对象是否是派生类的对象。如果是则转化成功，转化后的指针指向派生类对象，转化失败则会返回0。（通俗的理解，下行转化是由一个基类指针转化为派生类指针，此时这个基类指针可能指向的是基类对象，也有可能是派生类对象，所以会进行检查，如果基类指针指向的是派生类对象，则转化成功，否则为0）因此比static_cast更安全
- 需要基类包含虚函数，这样才能通过虚函数表查看继承关系

[【C++专题】static_cast, dynamic_cast, const_cast探讨](https://www.cnblogs.com/chio/archive/2007/07/18/822389.html)