# 关键字
## mutable
- 首先明确一点，当const修饰成员函数时（即const放在参数列表后面），成员函数不允许修改成员变量，除非这个成员变量被mutable修饰
- mutable一般会有两种用法：
    1. 修饰成员变量，一般和const一起用，这样可以使得在常成员函数中，可以修改被mutable修饰的变量
    2. 与lambda表达式一起用，表示表达式内传入的内部变量在修改的时候会同步修改外部的值（如果属于按值捕获，lambda表达式不允许修改从外部捕获的变量，即内部的赋值不会改变外部值。类似于值传递。但是如果使用mutable修改则可以改变）
## static
- 初始化时机：
> 全局变量，文件域的静态变量和类的静态成员变量在main之前的静态初始化过程中分配内存并初始化；局部静态变量（一般为函数内的静态变量）在第一次使用时分配内存并初始化。
- 线程安全性：
> 非局部静态变量一般在main执行之前的静态初始化过程分配内存并初始化，可以认为是线程安全的
> 局部静态变量在编译时，编译器的实现一般是在初始化语句之前设置一个局部静态变量的标识来判断是否已经初始化，运行的时候每次进行判断，如果需要则进行初始化，这个过程本身不是线程安全的。一般使用一个全局锁来控制局部静态变量的标识
- 作用域：
> 修饰全局变量时或者全局函数时，声明该变量或者函数只能在该文件中被访问，默认时extern，即全域能访问（在编译的时候使用导出符号表和未定义符号表来实现，在链接过程中将符号表中的符号地址填入，并重定向）。
> 修饰局部变量或函数，使其与类绑定而不是与对象绑定，因此静态成员函数不能访问非静态成员。
- 为什么要使用静态成员变量和静态成员函数？
> 1. 当调用一个对象的非静态成员函数时，系统会把该对象的起始地址赋给成员函数的this指针。而静态成员函数并不属于某一对象（所有对象共有，没有this指针，不能访问本类中非静态成员，有点惨），它与任何对象都无关。
> 2. **静态成员函数的出现就是为了处理静态成员变量**，（1）因为在有些场景下，没有生成对象就需要调用函数成员。（2）静态成员变量并不保存在对象的内存布局中，而是保存在数据段中，因而没有必要用到this指针。所以需要一种独立于对象之外对对象静态成员变量的访问操作。这样可以提高访问效率。
> 3. C++中，静态成员是属于整个类的而不是某个对象，静态成员变量只存储一份供所有对象共用。所以在所有对象中都可以共享它。使用静态成员变量实现多个对象之间的数据共享不会破坏隐藏的原则，保证了安全性还可以节省内存。
> 4. 静态成员的声明要加个关键static。静态成员可以通过双冒号来使用即<类名>::<静态成员名>，非静态成员则不能。
> 5. static成员变量**属于类（被存放在数据段中）**，不属于某个具体的**对象（具体对象的内存是分配在堆中的）**，即使创建多个对象，也只为该变量分配一次内存，所有对象使用的都是这份内存中的数据。若它为public类型，当某个对象修改了它，也会影响到其他对象，所有对象都是“同甘共苦的”
> 6. c++规定const静态类成员可以直接初始化，其他**非const的静态类成员需要在类外初始化，且不能使用static关键字**。我们一般选择在类的实现文件中实现它（定义（为其分配内存），初始化）。
- 为什么类的静态成员一定要在类内声明，并定义在类外？
> 1. 静态成员是“类级别”的，也就是它和类的地位等同，而普通成员是“对象（实例）级别”的。类级别的成员，先于该类任何对象的存在而存在，它被该类所有的对象共享
> 2. 假定要实例化该类的一个对象，那么会发生什么事情呢？静态成员肯定要出现在这个对象里面的，对吧？这时候才去定义那个静态成员吗？这显然是不合适的。因为，比如有另外一个线程也要创建该类的对象，那么也要按照这个方式去定义那个静态成员。这会产生两种可能的情况：**1. 重复定义；2. 就算不产生重复定义的情况，也会产生竞争，从而造成死锁的问题，以至于对象无法创建**。很显然，编译器不能这么干。那么很合理的解决办法，就是事先在类的外部把它定义好，然后再供所有的对象共享。
> 3. 类的静态常量成员可以在类内初始化，（因为**常量初始化是在编译期进行**，至少是在任何动态初始化之前）

[为什么需要静态成员函数和静态成员变量](https://blog.csdn.net/vict_wang/article/details/81288272)


## volatile（a situation that is volatile is likely to change suddenly and unexpectedly）
- 一般情况下，连续获取同一个变量的值，第一次对该变量进行访问内存后，CPU寄存器可能会有该值的缓存，所以第二次就不会访问内存获取新的数据，而是直接复用寄存器中的值，从而提高访问效率
- 该关键字表示该变量可能会发生不可预料（程序本身的行为都必须是可预期的，所以不可预期就是受到程序之外的影响）的变化，所以每次读取都是**读取最新的内存中的数据**
- volatile并不具有原子性，因为内部有多个子过程
- 可以理解为，被volatile修饰的变量能够保证每个线程能够获取到该变量的最新值，从而避免出现数据脏读的问题，可以说是提供的比较轻量级的同步机制
